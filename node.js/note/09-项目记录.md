# 〇、需求分析

1. 中间层，向前提供 HTTP 服务；
2. 中间层，向后提供 RPC 通信；

# 1、下载页

*  `npm i -g nodemon` 监听 node 服务器中依赖的文件，一旦有变更则自动重启服务器；
  * 使用 `nodemon index.js` 启动程序；
*  `npm i koa-mount` koa 框架下，负责路由中间件；
  * 优点：第二个参数可以是 koa 实例，可以将多个路由进行拆分包装，易于维护；
*  `npm i koa-static` koa 框架下，最初所有的资源文件都放到了 locallhost:9000 目录，使用 static 将资源文件正确匹配；

# 2、详情页

* 需求结构
  1. 使用 RPC 通信，从后台服务器获取数据；
     * 见【08-RPC通信】
  2. 模版引擎需要实现以下功能：
     1. include 子模版：
        * 将整体模版拆分成一个个小的子模版，方便维护；
     2. xss 过滤：
        * 后台返回的数据可能含有 `<script></script>` 标签中含有用户上传的恶意脚本；
        * 若前端不处理放到 `<html></html>` 中， `<script></script>` 标签中恶意脚本就会执行，产生安全隐患；
        * 前端需要将这些字符串，进行 xss 转译，将 `<` / `&` / `>` 尖括号，转译成特殊字符 `&lt;` / `&amp;` / `&gt;`；
        * 在 html 解析时会将这些字符串解析成纯文本，而不是 html 标签， `<script></script>` 标签中恶意脚本就不会执行；
        * 在 html 渲染时，也可以将这些转译后的字符串识别成 html ；
     3. 模版 helper 函数：
        * 帮助处理模版插入数据；

## 2.1、实现一个模版引擎（预演）

* 用 es6 模版字符串实现模版引擎（比较流行），因为是它所有模版引擎里性能最高的，但有些其它问题，需要费些功夫：

  1. 使用 **node/vm 模块** + **es6 模板字符串** ==实现==> ejs同样效果

     ```js
     //----【ejs 模版引擎的使用】------------------------------------------
     // const templateA = '<h1><%= user.name %></h1>';
     // ejs.render(template, user);
     
     const user = {
         name: 'thales'
     };
     const vm = require('vm');
     console.log(vm.runInNewContext('`<h1>${user.name}</h1>`', { user }));		// <h1>thales</h1>
     ```

  2. 在变量 user 后面，**添加 xss 过滤函数**(需 return 一个函数)，并在字符串中调用，达到 xss 过滤效果

     ```js
     const user = {
         name: '<script>alsert("thales")</script>'
     }；
     const vm = require('vm');
     const res = vm.runInNewContext(
         '`<h1>${XSSTranslation(user.name)}</h1>`',
         {
           	// ♨️ 此间补充的函数都需要 return 一个函数
             user,
             XSSTranslation
         }
     )
     
     function XSSTranslation (str) {
         if(!str) return '';
         return String(str)
             .replace(/&/g, '&amp;')
             .replace(/</g, '&lt;')
             .replace(/>/g, '&gt;')
             .replace(/"/g, '&quot;')
             .replace(/'/g, '&#39;')
     }
     
     console.log(res)		// <h1>&lt;script&gt;alsert(&quot;thales&quot;)&lt;/script&gt;</h1>
     ```

  3. 类似于 XSSTranslation 函数，往模版中**添加 helper 函数**(需 return 一个函数)

  4. 为了模拟模版引擎中可以引用其它子模版，需要**增加 include 函数**(需 return 一个函数)

     ```js
     const vm = require('vm');
     
     function include(name) {
         return templateMap[name]();
     }
     
     const templateMap = {
         templateB: '`<h1>${include("templateC")}</h1>`',
         templateC: '`<p>✅✅✅✅✅✅</p>`'
     };
     
     const context = { 
         user,
         XSSTranslation,
         include
     }
     
     Object.keys(templateMap).forEach(key => {
         const template = templateMap[key];
         // 将 template 对象重新组装成 { templateX: [Function (anonymous)]}，该匿名函数返回 '`xxxxx`'；
         templateMap[key] = vm.runInNewContext(`
             (function () {
                 return ${template}
             })
         `, context)
     })
     
     console.log(templateMap['templateB']())				// <h1><p>✅✅✅✅✅✅</p></h1>
     ```

## 2.2、实现一个模版引擎（实例）

