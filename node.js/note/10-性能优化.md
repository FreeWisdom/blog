# 性能优化

# 1、性能工具

## 1.1、HTTP 服务的性能测试

1. 压力测试工具

   * ab--ApacheBench

     ```shell
     ab -c200 -n1600 http://127.0.0.1:3000/download/
     ```

     ```shell
     Benchmarking 10.10.67.16 (be patient)
     Completed 100 requests
     Completed 200 requests
     Completed 300 requests
     Completed 400 requests
     Completed 500 requests
     Completed 600 requests
     Completed 700 requests
     Completed 800 requests
     Completed 900 requests
     Completed 1000 requests
     Finished 1000 requests
     
     # 服务器信息
     Server Software:
     Server Hostname:        10.10.67.16
     Server Port:            80
     
     Document Path:          /users  				# 请求路径
     Document Length:        676 bytes   		# 第一个成功返回的响应数据大小
     
     Concurrency Level:      10  						# 并发请求数量
     Time taken for tests:   1.260 seconds   # 总耗时
     Complete requests:      1000    				# 总请求数量
     Failed requests:        0   						# 请求失败数量
     Total transferred:      795000 bytes    # 从服务器接收数据大小
     HTML transferred:       676000 bytes    # 接收HTML大小
     Requests per second:    793.48 [/sec] (mean)   # ♨️ QPS 平均每秒请求数(总请求数量/总耗时) 793用户访问/s
     Time per request:       12.603 [ms] (mean) 		 # ♨️ 平均每批请求耗时（一批=总请求数量/并发请求数量）
     Time per request:       1.260 [ms] (mean, across all concurrent requests)   # ♨️ 平均每个请求耗时
     Transfer rate:          616.03 [Kbytes/sec] received 												# ♨️ 吞吐量 从服务器接收数据流量
     
     # 连接耗时详情
     Connection Times (ms)   
     #            最小值     均值     中值    最大值
                   min  mean[+/-sd] median   max
     Connect:        0    4  58.1      0    1063     # 与服务连接耗时
     Processing:     2    4   5.2      3      72     # 服务器处理请求耗时
     Waiting:        2    4   5.0      3      72     # 响应数据传输耗时
     Total:          2    8  58.2      4    1066     # 总耗时
     
     # 整体响应时间分布比
     Percentage of the requests served within a certain time (ms)    
       50%      4
       66%      4
       75%      5
       80%      5
       90%      7
       95%      9
       98%     20
       99%     41
      100%   1066 (longest request)
     ```

   * webbench

2. 找到性能瓶颈所在地

   * top----Linux 命令----监控 **cpu** & **内存**使用情况，进行上述压测时，同时服务器上跑 top ，就能看到 cpu 占用和 内存占用；
   * iostat----检测 i/o 设备**硬盘**的带宽；
   * 后端服务器----后端服务器 QPS 影响了 node 层的 QPS （少数）
     * 一般的瓶颈都是在 Node.js 的 cpu 运算能力上，体现在 cpu 占用率时 100% （js 代码写的不好）；

## 1.2、Node 性能分析工具

1. Node.js 自带 profile

   ```shell
   node --prof entry.js		# 生成 isolate-0x1046c2000-18349-v8.log 文件
   # 进行压测
   node --prof-process isolate-0x1046c2000-18349-v8.log > profile.txt	# 生成 txt 文件可以看到详细的文件执行耗时占比
   ```

2. Chrome devtool

   1. 输入命令行命令

   ```shell
   node --inspect-brk entry.js
   Debugger listening on ws://127.0.0.1:9229/5e01cf00-92ae-4f07-979c-de3ca48c9bfb
   For help, see: https://nodejs.org/en/docs/inspector
   Debugger attached.
   ```

   2. 浏览器打开 chrome://inspect
   3. 点击 Target (v14.16.0) 下的 inspect，出现 devtool
      * memory ---- 内存监控
      * profiler ---- 为 cpu监控
   4. 开启压测；
   5. 开启 cpu 监控录制⏺️按钮，进行压测，cpu 监控 stop ；
   6. 可以看到耗时占比；

# 2、代码优化

## 2.1、JS 代码性能优化

* Node.js HTTP 服务性能优化准则：
  * 提前计算（HTTP服务阶段的计算 --移动到--> 服务启动阶段）

```js
// 【优化1】readFileSync 从 app.use 中间件（http服务阶段）中提出来，到程序启动时做，极大减少了 readFileSync 的计算量占比；
// 				如果在mount里，也就是中间件里使用fs.readFileSync，相当于每一次请求都是从文件系统中取模板内容。
//				因为每一个http请求进来都会重新调用这堆中间件的；
//  			但你把fs.readFileSync提到外面，相当于提前把文件系统中的内容读取到内存中。中间件里是从内存中取得模板内容；
// 				从硬盘文件中取和从内存中取，高下立判，肯定是内存更快。

// 【优化2】把 readFileSync 的第二个参数 'utf-8' 删除，直接生成二进制 buffer 给到前端，减少了 '二进制' 与 'utf-8'之间的冗余转换（因为 node 底层 c++ 会用 ‘二进制’ 传给前端）；
const buffer = fs.readFileSync(__dirname + '/source/index.html');
app.use(
    mount('/', async (ctx) => {
        ctx.status = 200;
        ctx.type = 'html';
        ctx.body = buffer
    })
)
```

## 2.2、内存管理优化

* 使用 devtools 检测内存泄漏定位

  1. 命令行输入

     ```shell
     node --inspect-brk entry.js
     ```

  2. 浏览器打开 chrome://inspect

  3. 点击 Target (v14.16.0) 下的 inspect，出现 devtool

     * memory ---- 内存监控

  4. 开启压测，点击快照；

  5. 压测完毕，点击快照；

  6. 对比快照中，即可找到内存泄漏的变量；

* 节省内存最好的方式：

  * 使用 “池” （即，Node.js 中 buffer 的内存分配策略）

## 2.3、Node.js C++ 插件

# 3、多进程优化

# 4、架构优化



